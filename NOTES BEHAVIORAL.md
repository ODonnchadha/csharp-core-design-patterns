- TEMPLATE METHOD:
  - This is a fundamental pattern RE: code reuse.
  - The intent of this pattern is to define the skelton of an algorithm in a operation, deferring some steps to subclasses.
  - It lets subclasses redefine certain steps for an algorithm without changing the algorithm's structure.
  - The steps needed to be executed are the same for all classes, but some implementations can differ.
  - Abstract class defines the abstract primitive operations that concrete subclasses define to implement steps of an algorithm.
  - Also implements a template method defining the skeleton of an algorithm.
  - Concrete class implements the primitive operations to carry out subclass-specific steps of the algorithm.
  - Use Cases:
    - When you want to implement invariant parts of an algorithm only once, and want to leave it to subclasses to implement the rest of the behavior.
    - When you want to control which part of an algorithm subclasses can vary.
    - When you have a set of algorithms that don't vary much.
  - Pattern Consequences:
    - Template methods are fundamental technique for code reuse.
    - Template methods cannot be changed: The order of the methods thaey call is fixed:
  - Related Patterns:
    - Factory Method: Can be viewed as a specialization of template method. Template methods often use factory methods as part of their skeleton structure.
    - Strategy: Template method allows varying part of an algorithm through inheritance: A static approach. Strategy allows behavior to be switched at runtime, via composition: A dynamic approach.
  - Summary:
    - To define the skeleton of an algorithm in the operation, deferring some steps to subclasses.
    - Define the template method on the abstract base class and don't allow overridding it.
    - Mark methods that differ per subclass as abstract. Mark mwthods that differ for some subclasses as virtual.

- STRATEGY:
  - AKA Policy pattern.
  - The intent of this pattern is to define a family of algorithms, encapsulate each one, and then make them interchangeable. 
  - Strategy lets the algorithm vary independently from clients that use it.
  - The Players:
    - Strategy declares an interface common to all supported algorithms. Context uses it to call the algorithm defined by a concrete strategy.
    - Context is configured with a Concrete Strategy object and maintains a reference to a Strategy object.
  - Implementating a strategy pattern variation with a method parameter:
    ```csharp
      public void Export(IExportService service);
    ```
  - Use Cases:
    - When many related classes differ only in their behavior.
    - When you need different variants of an algorithm which you want to be able to switch a runtime.
    - When your algorithm uses data, code, or dependencies that the clients shouldn't know about.
    - When a class defines many different behaviors which appear as a bunch of conditional statements in its method.
  - Pattern Consequences:
    - It offers an alternative to subclassing your context.
    - New strategies con be introduced without having to change the context: Open/closed principle.
    - It eliminates conditional statements.
    - It can provide a choice of implementations with the same behavior.
    - If the client injects the strategy, the client must be aware of how strategies differ.
    - There's overhead in communication between the strategy and the context.
    - Additional objects are introduced, which increases complexity.
  - Related Patterns:
    - Flyweight: Strategy objects make good flyweights.
    - Bridge: Also based on composition, but solves a different problem.
    - State: Also based on composition, but solves a different problem.
    - Template Method: Allows varying part of an algorithm through inheritance: A static approach. Strategy allows behavior to be switched at runtime via composition: A dynamic approach.
  - Summary:
    - To define a family of algorithms, encapsulate each one, and make them interchangeable.
    - Common variation: Concrete strategy injected via method parameter.

- COMMAND:
  - The intent of this pattern is to encapsulate a request as an object, there letting you parameterize clients with different requests, queue or logs requests, and support undoable operations.
  - The command pattern allows decoupling the requester of an action from the receiver.
  - Very common in mobile or rich UI development.
  - The Players:
    - Invoker asks Command to carry out a request.
    - Command declares an interface for executing an operation.
    - Concrete Command defines a bidning between a Receiver and an action. It implements Execute() by invoking the corresponding operation(s) on a Receiver.
    - Receiver knows how to perform the operation(s) associated with carrying out a request.
    - Client creates the COncrete Command and sets its Receiver.
  - Use Cases:
    - When you want to parameterize objects with an action to perform.
    - When you want to support undo.
    - When you want to specify, queue, and execute requests at differet times.
    - When you need to store a list of changes to potentially reapply later on.
  - Pattern Consequences:
    - It decouples the class that invokes the peration from the one that knows how to perform it: Single responsibility principle.
    - Command can be manipulated and extended.
    - Commands can be assembled into a composite command.
    - Existing implementations don't have to be changed to add new commands: Open/closed principle.
    - Because an additional layer is added, complexity increases.
  - Related Patterns:
    - Composite: Can be used to implement commands composed of other commands.
    - Memento: Can be used to store the state a command requires to undo its effect.
    - Prototype: In case of supporting undo, a command that must be copied acts as a prototype.
    - Chain Of Responsibility: Handlers can be implemented as commands.
  - Patterns That Connect Senders & Receivers:
    - Chain Of Responsibility: Passes a request along a chain of receivers.
    - Command: Connects senders with receivers unidirectionally.
    - Mediator: Eliminates direct connections altogether.
    - Observer: Allows receivers of requests to (un)subscribe at runtime.
  - Summary:
    - Intended to encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.
    - Define methods on command. IMplement on concrete command.
    - Invoker is often a UI element. Receiver can be any object.
    - Consider using a command manager. e.g.: Undo/redo.

- MEMENTO:
  - AKA token pattern.
  - The intent of this pattern is to capture and externlize an object's internal state so that the onject can be restored to this state later, without violation encapsulation.
  - Store and restore private field and property values.
  - Solve with memento: Making internal state public breaks encapsulation.