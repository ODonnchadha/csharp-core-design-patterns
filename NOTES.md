## C# 10 Design Patterns by Kevin Dockx
- This course will teach you how to improve code base by using tested and proven object-oriented design patterns.

- COURSE OVERVIEW:
  - Real-life examples. Use cases and associated consequences. And related patterns.

- INTRODUCTION TO DESIGN PATTERNS:
  - .NET 6.0 & C# 10. Visual Studio 2022. Prerequisites, frameworks, & tooling. GO4.
  - All 23 GO4 patterns are covered. Intent. Structure. Implementation.
  - The pattern internt should remain the same, regardless of surrounding implementation. Know what opportunity the pattern does resolve.
  - Creational:
    - Five patterns dealing with object creation.
      - Abstracting the object instantiation process.
      - Making the system independent of how its objects are created, composed, and represented.
  - Structural:
    - Seven patterns defining the relations between classes.
      - Concerned with how classes & objects are composed to form larger structures.
  - Behavioral:
    - Eleven patterns dealing with ways to communicate between classes or objects.
      - Characterize complex control flow that's difficult to follow at runtime. Concentrate on how objects are interconnected.
  - Object-oriented principles:
    - Program to an interfaces and not an implementation.
      - This allows for loose coupling.
      - Clients remain unaware of the specific types of objects they use as long as the objects adhere to the interface expected.
      - Client remain unaware of the classes that implement these objects. Clients only know about the interface.
      - Interface vs abstract class:
        - Use an abstract base class when you need to provide some basic functionality that can potentially be overridden.
        - Use an interface when you only need to specify the expected functionality of a class.
      - Commonly correlates to adhering to the open/closed principle. SOLID.
        - Software entities should be open for extension but closed for modification.
    - Favor object composition over class inheritance.
      - CLass inheritance. Lets you define the implementation of one class in terms of another.
      - Object composition: New functionality is obtained by assembling or composing objects to get more complex functionality.
      - Inheritance tends to be overused. Composition often simplifies desgins and makes them more reuseable.
      - And commonly correlates to adhering to the single responsibility principle SOLID.
        - A class should have one, and only one, reason to change.
  - Summary:
    - A design pattern is a general, reuseable solution to a commonly occuring problem within a given context in software design.
    - Creational patterns help with making your system independent of how its objects are created, composed, and represented.
    - Structural patterns are concerned with how classes and objects are composed to form larger structures.
    - Behavorial patterns characterize complex control flow that's difficult to follow at runtime, and let you concentrate on the way objects are interconnected.

- CREATIONAL PATTERN: SINGLETON:
  - The intent of the singleton pattern is to ensure that a class only has one instance and to provide a global point of access to it.
  - Real-life example. Logger. One instance is prefered.
  - Holding the class instance in a global veriable doesn't prevent cliets from creating other instances of the class.
  - Make the class responsible for enxuring only one instance of itself exists.
  - Logger() (private/protected.) static Logger? Instance. return _instance. static Logger? _instance.
  - Log(). Regular instance methods. Not static.
  - Prefer lazy instantiation:
    - Create and store the instance when it is requested for the first time and return that instance on subsequent requests.
  - A singleton defines an instamce operation that lets clients access its unique instance.
  - Ensure that lazy initialization is thread-safe.
  - Pattern consequences:
    - Strict control over how and when clients access it.
    - Avoids polluting the namespace with global variables.
    - Subclassing allows configuring the application with an instance of the class you need at runtime.
    - Multiple instances can be allowed without having to alter the client.
    - Violates the single responsibility principle. This is all mostly dealt with via an IOC container.
  - Related patterns? Can be implemented as a singleton: Abstract factory. Builder. Prototype. State.
  - Summary:
    - Ensure that a class only has one instance with global access to it.

- CREATIONAL PATTERN: FACTORY METHOD:
  - "Virtual constructor."
  - The intent is to define an interface for creating an object, but to let the subclasses decide which class to instantiate. 
  - Factory method lets a class defer instantiation to subclasses.
  - Product defines the interface of objects that the factory method creates.
  - Concrete product implements the product interface.
  - The creator declares the factory method, which must return a product.
  - Concrete creator implements creator and overrides the factory method to return an instance of concrete product.
  - Use cases:
    - Whan a class can't anticipate the class of objects it must create.
    - When a class wants its subclasses to specify the objects it creates.
    - When classes delegate responsibility to one of several helper subclasses, and you want to localize knowledge of which helper subclass is the delegate.
    - As a way to enable reusing of existing objects.
  - Consequences:
    - Eliminate the need to bind application-specific classes to your code. The code only deals with the interface.
    - New types of products can be added without breaking client code. open/closed principle.
    - Creating products is moved to one specific place in your code: the creator. single responsibility principle.
    - Clients might need to create subclasses or the creator class just to create a particular concrete product object.
  - Related patterns:
    - Abstract factory. Often implemented with factory methods.
    - Prototype. No subclassing is needed as it is not based on inheritance, but an initialize action on product is often required.
    - Template. Factory methods are often called from within template methods. 
  - Summary:
    - Define an interface for creating an object but let subclasses decide which class to instantiate.
    - Eliminate the need to bnd application-specific classes to code.
    - Product or creator can be implemented as interface, or abstract, base class.

- CREATIONAL PATTERN: ABSTRACT FACTORY:
  - The intent of te abstract factory pattern is to provide an interface for creating families of related or dependent objects without specifying their concrete classes.
  - Provide a concrete factory implementation via the constructor.
  - The client is decoupled from the concrete factory implementation.
  - Use cases:
    - When a system should be independent of how its products are created, composed, and represented.
    - When you want to provide a class library of products and you only want to reveal their interfaces and not their implementations.
    - When a system should be configured with one of multiple familes of products.
    - When a family of related product objects is designed to be used together and you want to enforce this constraint.
  - Consequences:
    - It isolates concrete classes because it encapsulates the responsibility and the process of creating product objects.
    - New products can easily be introduced without breaking client code. Open/closed principle.
    - Code to create products is contained in one place. Single responsibility principle.
    - It makes exchanging product familes easy.
    - It promotes consistency among products.
    - Supporting new kinds of products is rather difficult.
  - Factory Method & Abstract Factory comparisons:
    - Factory Method: 
      - Exposes an interface with a method on it to create on object of a certain type.
      - Produces one product.
      - Creates objects through inheritance.
    - Abstract Factory:
      - Exposes and interface to create related objects: families of objects.
      - Produces a family of products.
      - Creates families if objects through composition.
  - Related patterns:
    - Abstract method. Can be implemented using factory methods.
    - Prototype. Abstract factory can be implemented using prototypes.
    - Singleton. A concrete factory is often implemented as a singleton.
  - Summary:
    - Provide an interface for creating families of related or dependent bjects without specifying their concrete classes.
    - Clients are isolated from implementation class. Decoupled.
    - Return ConcreteProduct via the underlying interface.

- CREATIONAL PATTERN: BUILDER:
  - The intent of the builder pattern is to seperate the construction of a complex object from its representation.
  - By doing so, the same construction process can create different representations.
  - Creating a complex object is transparent for the consumer of the builder. Work on interfaces. Not implementations.
  - Builder specifies an abstract interface for creating parts of a Product object.
  - COncrete builder constructs and assembles parts of the product by implementing the builder interface.
  - It keeps track of the representation it creates, and provides an interface for retrieving the product.
  - Product represents a complex object under construction.
  - Director constructs the object using the builder interface.
  - Use cases:
    - When you want to make the algorithm for creating a complex object independent of the parts that make us the object and how they're assembled.
    - When you want the construction process to allow different representations for the object that's constructed.
  - Consequences:
    - It lets us vary a products' internal representation.
    - It isolates code for construction and representation. Thus improving modularity by encapsulating the way a complex object is constructed and represented. Single responsibility principle.
    - It gives us finer control over the construction process.
    - Complexity f the codebase increases.
  - Related patterns:
    - Abstract factory: Bot can be used to construct complex objects, but the builder constructs the complex objects step-by-step.
    - Singleton: A builder can be implemented as a singleton.
    - Composite: Composites are often built by builders.
    - Summary:
      - Seperate the cnstruction of a complex object from its representation so the same construction process can create different representations.
      - Use it when you want to make the algorithm for creating a complex object independent of the oarts that make up the object and how they're assembled.
      - Define an abstract base class or interface as Builder and have the director work on the builder and not the concrete builder implementations.

- CREATIONAL PATTERN: PROTOTYPE:
  - The intent of this pattern is to specify the kinds of objects to create using a ptototypical instance, and create new objects by copying this prototype.
  - Remove client requirement to have intrinsic knowledge of concrete classes ad how to create them.
  - Prototype declares an interface for cloning itself.
  - Concrete Prototype implements an operation for cloning itself.
  - Client creates a new object by asking a prototype to clone itself.
  - Shallow copy:
    - Copy of primitive type values
    - Complex type values will be shared across clones.
  - Deep copy:
    - Copy of priitive values and complex type values.
  - ICloneable interface:
    - ICloneable enables us to provide a customized implementation that creates a copy of an existing object.
    - Disadvantages. 
      - It does not specify whether the cloning operation performs a deep copy, a shallow copy. or something inbetween.
      - It doesn't require all property values of the original instance to be copied to the new instance.
      - It returns an object, which means that the client would need an additional cast.
  - Use Cases:
    - When a system should be independent of how its objects are created and to avoid building a set of factories that mimic the class hierarchy.
    - When a system should be independent of how its objects are created and when instances of a class can have one of only a few different combinations of states.
  - Consequences:
    - Prototype hides the concrete product classes from the client, which reduces what the client needs to know.
    - Reduced subclassing.
    - Each implementation of the prototype base class must implement its own clone method.
  - Related patterns:
    - Abstract factory: Might store a set of prototypes from which it clones when a new instance is requested.
    - Factory method: Based on inheritance, but doesn't require an initization step.
    - Singleton: Can be implemented as a singleton.
    - Composite: Can use prototype for convenient object creation.
    - Decorator: Can use prototype for convenient object creation.
  - Summary:
    - Intent is to specify the kinds of objects to create using a prototypical instance and to create new objects by copying this prototype.
    - Implementation means that subclasses implement the Clone() method and clients work on the prototype.
    - SHallow copy is a copy of primitive types values, which a deep copy is a copy of primitive type values and complex type values.

- STRUCTURAL PATTERN: ADAPTER:
  - AKA "Wrapper" pattern. Class adapter & object adaper.
  - Intent of this pattern is to convert the interface of a class into another interface client expect.
  - Adapter allows for classes to work together that could not otherwsie because of incompatible interfaces.
  - Two variations. "Adapt the external system."
  - Object adapter:
    - Adaptee defines an existing interface that needs to be adapted.
    - Target defines the domain-specific interface that the client works with.
    - Client collaborates with objects conforming to the target interface.
    - Adapter adapts the interface of the adaptee to the target interface.
  - Class adapter:
    - C# prefers composition over inheritance and does not support multiple inheritance.
    - Adapter dervives from the adaptee.
  - Use cases:
    - When you want to use an existing class but the interface does not match the one you need.
    - When you want to create a reuseable class, the adapter, that works with classes that don't have compatible interfaces.
    - When you need to use several existing subclasses, don't want to create additional subclasses for each of them, but still need to adapt their interface.
  - Consequesnces:
    - A single adapter can work with many adaptees, and can add functionality to all adaptees at once.
    - The interface is separated out from the rest od the code. Single responsobility principle.
    - New types of adapters can be introduced withut breaking client code. Open/closed principle.
    - The object adapter makes it hard to override adaptee behavior.
    - Aditional complexity is introduced.
  - Related:
    - Bridge: Seperates interface from implementation, adapter changes the interface of an existing object.
    - Decorator: Changes an obkect without changing its interface, adapter changes the interface of an existing object.
    - Facade: You define a new interface for an entire subsystem, with adapter you'ree making an eisting interface useable via wrapping.
    - Proxy: Defines a surrogate for another object, but does not change its interface.
  - Summary:
    - Lets classses work together that couldn't before because of incompatible interfaces.
    - Object adapter relies on composition. Class adapter relies on multiple inheritance.

- STRUCTURAL PATTERN: BRIDGE:
  - The intent of this pattern is to decouple an abstraction from its implementation so the two can vary independently.
  - Seperate abstraction from implementation.
    - A means to replace an implementation with another implementation without modifying the abstraction.
    - Think of an abstraction as a way to simplify something complex. e.g.: Console.WriteLine();
    - Abstractions handle complexity by hiding the parts we don't need to know about.
    - Subclassing is one way to add functionality. Subclassing tends to add avoidable complexity.
  - Abstraction defines the abstraction's interface and holds a reference to the implementor.
  - Refined abstraction extends the interface defined by abstraction.
  - Implementor defines the interface for imlementation classes.
  - Concrete implementor implements the implementor interface and defines its concrete implementation.
  - Use cases:
    - When you want to avoid a permanent binding between an abstraction and its implementation (to enable swithing implementations at runtime.)
    - When abstraction and implementations should be extensible by subclassing.
    - When you don't want changes in the implementation of an abstraction to have an impact on the client.
  - Pattern consequences:
    - Decoupling: The implementation isn't permanently bound to thr abstraction.
    - As the abstraction and implementation hiearchies can evolve independently, new ones can be introduced as such. Open/closed principle.
    - You can hide implementation details away from clients.
    - You can focus on high-level logic in the abstraction and on the details in the implementation. Single responsibility principle.
  - Related patterns:
    - Abstract factory: Factory can create and configure a bridge.
    - Adapter: Adapter lets unrelated classes wrk together, bridge lets abstractions and implementation vary independently.
    - Strategy: Based on composition, like bridge.
    - State: Based on composition, like bridge.
  - Summary:
    - Decouple an abstraction from its implementation so the two can vary independently.
    - Main consequences: Decoupling. Improved extensibility. Hidden implementation details.

- STRUCTURAL PATTERN: DECORATOR:
  - The intent of the pattern s to attach additional responsibilities to an object dynamically. 
  - A decorator thus provides a flexible alternative to subclassing for extendung functionality. "Wrapper." (Like adapter.)
  - Adding responsibility to a class can be done by adding an additional method to the class.
  - We don't want to add that responsibility to a class, we want to add it to an instance of a class, an object, at runtime.
  - Classes can be extended with additional functionality:
    - Leads to violations of the single responsibility principle.
    - Classes get littered with code that doesn't belong there.
  - Component defines the interface for objects that can have responsibilities added to them dynamically.
  - Concrete component defines an object to which additional responsibilities can be attached.
  - Decorator maintains a reference to a component object, and defines an interface that conforms to the component's interface.
  - Concrete decorator adds responsibilities to the component.
    - When you have a need to add responsibilities to individual objects dynamically without affecting other objects.
    - When you need to be able to withdraw responsibilities you attached to an object.
    - When extension by subclassing is impractical or impossible.
  - Pattern Consequences:
    - More flexible than using static inheritance via subclassing: Responsibilities can be added and removed at runtime as hoc.
    - You can use the pattern to split feature-loaded classes until there's just one responsibility left per class: Single responsibility principle.
    - Increased efort is required to learn the system due to the amount of small, simple classes.
  - Related Patterns:
    - Adapter: Gives a new interface to an object, decorator only changes its responsibilities.
    - Composite: Adapter can be seen as a composite with only one component.
    - Strategy: Decorator lets you change the skin of an object, strategy lets you change its inner workings.
  - Summary:
    - Attach additional responsibilities to an object dynamically.
    - More flexible than static inheritance through subclassing.

- STRUCTURAL PATTERN: COMPOSITE:
  - The intent of this pattern is to compose objects into tree structures to represent part-whole hierarchies.
  - As such, it lets clients treat individual objects and compositions of objects unifornly: as if they all were individual objects.
  - e.g.: XML document structure.
  - Intrinsic knowledge about the object type is required: Class. Method to call. Nesting level.
  - Component declares the interface for objects on the compositions, and contains a common operation.
  - Leaf represents leaf objects in the composition, and has no children. It defines behavior for primitive objects in the composition.
  - Composite sotres child components and defines behavior for components having children.
  - Client manipulates objects in the composites through the component interface.
  - Variations exist.
    - Original template defines an operation to get a specific child.
    - Original template defines child management operations on the component abstract base class.

- STRUCTURAL PATTERN: FACADE

- STRUCTURAL PATTERN: PROXY

- STRUCTURAL PATTERN: FLYWEIGHT